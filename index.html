<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ° Slot Machine Pro - Ø§Ù„Ø¹Ø¨Ø© Ø§Ù„Ø³Ù„ÙˆØª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©</title>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@300;400;500;700;800&display=swap" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* ===== RESET & BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© */
            --primary: #8B5CF6;
            --primary-dark: #7C3AED;
            --primary-light: #A78BFA;
            --secondary: #EC4899;
            --secondary-dark: #DB2777;
            --accent: #10B981;
            --accent-dark: #059669;
            --danger: #EF4444;
            --danger-dark: #DC2626;
            --warning: #F59E0B;
            --warning-dark: #D97706;
            --info: #3B82F6;
            --dark: #1F2937;
            --darker: #111827;
            --darkest: #0B1121;
            --light: #F3F4F6;
            --lighter: #F9FAFB;
            --gray: #6B7280;
            --gray-light: #9CA3AF;
            --gray-dark: #4B5563;
            
            /* Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù…Ø®Ø§Ø²Ù† */
            --store-1: #3B82F6;
            --store-2: #8B5CF6;
            --store-3: #10B981;
            
            /* Ø§Ù„Ø¸Ù„Ø§Ù„ */
            --shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            --shadow-light: 0 5px 15px rgba(0, 0, 0, 0.2);
            --shadow-dark: 0 15px 35px rgba(0, 0, 0, 0.4);
            --shadow-inset: inset 0 2px 5px rgba(0, 0, 0, 0.2);
            --shadow-glow: 0 0 20px rgba(139, 92, 246, 0.5);
            
            /* Ø§Ù„Ø²ÙˆØ§ÙŠØ§ */
            --radius: 16px;
            --radius-sm: 10px;
            --radius-lg: 24px;
            --radius-xl: 32px;
            --radius-full: 9999px;
            
            /* Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„Ø§Øª */
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: 'Tajawal', sans-serif;
            background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            direction: rtl;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(236, 72, 153, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(16, 185, 129, 0.05) 0%, transparent 50%);
            z-index: -1;
            pointer-events: none;
        }

        /* ===== CONTAINER ===== */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
        }

        /* ===== HEADER ===== */
        .header {
            background: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(10px);
            border-radius: var(--radius);
            padding: 20px 30px;
            margin-bottom: 30px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .balance-container {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            padding: 12px 25px;
            border-radius: var(--radius);
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: var(--shadow);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .balance-icon {
            font-size: 1.8em;
        }

        .balance-amount {
            font-size: 2em;
            font-weight: 800;
        }

        .player-id {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: var(--radius-sm);
            font-size: 0.9em;
            color: var(--gray-light);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .game-title {
            text-align: center;
            flex-grow: 1;
        }

        .game-title h1 {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 2.5em;
            font-weight: 800;
            margin-bottom: 5px;
        }

        .game-title p {
            color: var(--gray-light);
            font-size: 1.1em;
        }

        .controls-header {
            display: flex;
            gap: 12px;
        }

        /* ===== GAME AREA ===== */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 450px;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1200px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        /* ===== SLOT MACHINE ===== */
        .slot-machine {
            background: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(10px);
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            border: 3px solid rgba(139, 92, 246, 0.3);
            position: relative;
            overflow: hidden;
        }

        .slot-frame {
            background: rgba(0, 0, 0, 0.5);
            border-radius: var(--radius-sm);
            padding: 20px;
            border: 2px solid rgba(236, 72, 153, 0.3);
            margin-bottom: 25px;
            position: relative;
            overflow: hidden;
        }

        .reels-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            height: 300px;
        }

        .reel-cell {
            background: linear-gradient(145deg, #2D3748, #1F2937);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            position: relative;
            transition: var(--transition);
            box-shadow: var(--shadow-inset);
            border: 2px solid rgba(255, 255, 255, 0.05);
        }

        .reel-cell.spinning {
            animation: spin 0.1s linear infinite;
        }

        @keyframes spin {
            0% { transform: translateY(0); }
            100% { transform: translateY(-100px); }
        }

        .reel-cell.matched {
            animation: pulse 0.5s ease infinite alternate;
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }

        /* ===== CONTROL PANEL ===== */
        .control-panel {
            background: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(10px);
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            border: 2px solid rgba(236, 72, 153, 0.3);
        }

        .section-title {
            color: var(--accent);
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }

        .bet-controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 25px;
        }

        .bet-display {
            text-align: center;
            margin-bottom: 20px;
        }

        .bet-amount {
            font-size: 3em;
            font-weight: 800;
            color: var(--accent);
        }

        .bet-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .spin-controls {
            display: flex;
            gap: 15px;
        }

        .btn {
            border: none;
            border-radius: var(--radius-sm);
            font-family: 'Tajawal', sans-serif;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 15px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            flex: 2;
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger), var(--danger-dark));
            color: white;
            flex: 1;
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning), var(--warning-dark));
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: white;
        }

        .btn-info {
            background: linear-gradient(135deg, var(--info), #2563EB);
            color: white;
        }

        .btn-bet {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-bet.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            box-shadow: var(--shadow-light);
        }

        /* ===== STORES PANEL ===== */
        .stores-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 25px;
        }

        .store {
            margin-bottom: 20px;
        }

        .store-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .store-label {
            font-weight: 600;
        }

        .store-amount {
            font-weight: 700;
            color: var(--accent);
        }

        .store-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .store-fill {
            height: 100%;
            transition: width 0.5s ease;
        }

        .store-1 .store-fill { 
            background: linear-gradient(90deg, var(--store-1), #60A5FA);
        }
        .store-2 .store-fill { 
            background: linear-gradient(90deg, var(--store-2), #A78BFA);
        }
        .store-3 .store-fill { 
            background: linear-gradient(90deg, var(--store-3), #34D399);
        }

        /* ===== STATS PANEL ===== */
        .stats-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: var(--radius-sm);
            padding: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: var(--radius-sm);
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--gray-light);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: var(--accent);
        }

        /* ===== WIN DISPLAY ===== */
        .win-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.95), rgba(17, 24, 39, 0.95));
            padding: 40px 60px;
            border-radius: var(--radius-lg);
            border: 4px solid var(--accent);
            text-align: center;
            z-index: 1000;
            display: none;
            box-shadow: var(--shadow-dark);
            backdrop-filter: blur(10px);
        }

        .win-display.active {
            display: block;
            animation: popIn 0.5s ease;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .win-amount {
            font-size: 4em;
            font-weight: 900;
            color: #FBBF24;
            margin: 20px 0;
            text-shadow: 0 0 20px #FBBF24;
        }

        .win-close {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: var(--radius-sm);
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 20px;
        }

        /* ===== LOADING ===== */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(139, 92, 246, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loading-message {
            color: var(--light);
            font-size: 1.2em;
            margin-top: 10px;
        }

        /* ===== CLOUD STATUS ===== */
        .cloud-status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(31, 41, 55, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: var(--radius);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            z-index: 100;
            border: 2px solid transparent;
            backdrop-filter: blur(10px);
        }

        .cloud-status.connected {
            border-color: var(--accent);
        }

        .cloud-status.disconnected {
            border-color: var(--danger);
        }

        /* ===== TOAST ===== */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(31, 41, 55, 0.95);
            color: white;
            padding: 15px 25px;
            border-radius: var(--radius);
            border-right: 4px solid var(--accent);
            box-shadow: var(--shadow);
            transform: translateX(100%);
            transition: transform 0.3s;
            z-index: 1000;
            backdrop-filter: blur(10px);
            max-width: 350px;
        }

        .toast.show {
            transform: translateX(0);
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }
            
            .header {
                flex-direction: column;
                text-align: center;
            }
            
            .reels-container {
                height: 250px;
            }
            
            .reel-cell {
                font-size: 2.5em;
            }
            
            .bet-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .win-display {
                padding: 30px;
                width: 90%;
            }
            
            .cloud-status {
                top: 10px;
                left: 10px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-message" id="loadingMessage">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©...</div>
    </div>

    <!-- Cloud Status -->
    <div class="cloud-status disconnected" id="cloudStatus">
        <i class="fas fa-cloud-slash"></i>
        <span>ØºÙŠØ± Ù…ØªØµÙ„</span>
    </div>

    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="player-info">
                <div class="balance-container">
                    <span class="balance-icon">ğŸ’</span>
                    <span class="balance-amount" id="balance">10,000</span>
                </div>
                <div class="player-id" id="playerId">...</div>
            </div>
            
            <div class="game-title">
                <h1>ğŸ° Slot Machine Pro</h1>
                <p>Ø§Ù„Ø¹Ø¨Ø© Ø§Ù„Ø³Ù„ÙˆØª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©</p>
            </div>
            
            <div class="controls-header">
                <button class="btn btn-info" id="syncBtn">
                    <i class="fas fa-sync-alt"></i>
                </button>
                <button class="btn btn-warning" id="soundToggle">
                    <i class="fas fa-volume-up"></i>
                </button>
                <button class="btn btn-success" id="resetGame">
                    <i class="fas fa-redo"></i>
                </button>
            </div>
        </header>

        <!-- Game Area -->
        <div class="game-area">
            <!-- Slot Machine -->
            <div class="slot-machine">
                <div class="slot-frame">
                    <div class="reels-container" id="reels">
                        <!-- Will be filled by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="control-panel">
                <!-- Bet Controls -->
                <div class="bet-controls">
                    <div class="section-title">ğŸ¯ Ø§Ù„Ø±Ù‡Ø§Ù† Ø§Ù„Ø­Ø§Ù„ÙŠ</div>
                    <div class="bet-display">
                        <div class="bet-amount" id="currentBet">500</div>
                    </div>
                    
                    <div class="bet-buttons">
                        <button class="btn btn-bet" data-bet="100">100</button>
                        <button class="btn btn-bet" data-bet="250">250</button>
                        <button class="btn btn-bet active" data-bet="500">500</button>
                        <button class="btn btn-bet" data-bet="1000">1,000</button>
                        <button class="btn btn-bet" data-bet="2500">2,500</button>
                        <button class="btn btn-bet" data-bet="5000">5,000</button>
                    </div>
                    
                    <div class="spin-controls">
                        <button class="btn btn-primary" id="spinBtn">
                            <i class="fas fa-play"></i> ØªØ¯ÙˆÙŠØ± (Space)
                        </button>
                        <button class="btn btn-danger" id="stopBtn" disabled>
                            <i class="fas fa-stop"></i> Ø¥ÙŠÙ‚Ø§Ù (Space)
                        </button>
                    </div>
                </div>

                <!-- Stores Panel -->
                <div class="stores-panel">
                    <div class="section-title">ğŸ¦ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø®Ø§Ø²Ù†</div>
                    <div class="store">
                        <div class="store-header">
                            <div class="store-label">Ø§Ù„Ù…Ø®Ø²Ù† Ø§Ù„ØµØºÙŠØ±</div>
                            <div class="store-amount" id="store1Amount">300,000</div>
                        </div>
                        <div class="store-bar">
                            <div class="store-fill" id="store1Fill" style="width: 60%;"></div>
                        </div>
                    </div>
                    
                    <div class="store">
                        <div class="store-header">
                            <div class="store-label">Ø§Ù„Ù…Ø®Ø²Ù† Ø§Ù„ÙƒØ¨ÙŠØ±</div>
                            <div class="store-amount" id="store2Amount">900,000</div>
                        </div>
                        <div class="store-bar">
                            <div class="store-fill" id="store2Fill" style="width: 45%;"></div>
                        </div>
                    </div>
                    
                    <div class="store">
                        <div class="store-header">
                            <div class="store-label">Ù…Ø®Ø²Ù† Ø§Ù„Ø·ÙˆØ§Ø±Ø¦</div>
                            <div class="store-amount" id="store3Amount">200,000</div>
                        </div>
                        <div class="store-bar">
                            <div class="store-fill" id="store3Fill" style="width: 20%;"></div>
                        </div>
                    </div>
                </div>

                <!-- Stats Panel -->
                <div class="stats-panel">
                    <div class="section-title">ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">Ø¹Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±Ø§Øª</div>
                            <div class="stat-value" id="totalSpins">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Ù†Ø³Ø¨Ø© Ø§Ù„ÙÙˆØ²</div>
                            <div class="stat-value" id="winRate">0%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Ø£ÙƒØ¨Ø± ÙÙˆØ²</div>
                            <div class="stat-value" id="biggestWin">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Ù…Ø¹Ø¯Ù„ RTP</div>
                            <div class="stat-value" id="rtpRate">96.5%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Win Display -->
    <div class="win-display" id="winDisplay">
        <div style="font-size: 2em; color: var(--accent); margin-bottom: 10px;">ğŸ‰ ÙÙˆØ² Ø±Ø§Ø¦Ø¹! ğŸ‰</div>
        <div class="win-amount" id="winAmount">0</div>
        <div style="color: var(--warning); font-size: 1.2em; margin-bottom: 20px;">
            Ù…Ø¶Ø§Ø¹Ù: <span id="winMultiplier">Ã—1</span>
        </div>
        <button class="win-close" id="closeWin">Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ù„Ø¹Ø¨</button>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Audio Elements -->
    <audio id="spinSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-slot-machine-spin-1073.mp3" type="audio/mpeg">
    </audio>
    <audio id="stopSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" type="audio/mpeg">
    </audio>
    <audio id="winSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>
    <audio id="clickSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-select-click-1109.mp3" type="audio/mpeg">
    </audio>

    <!-- JavaScript -->
    <script>
        // ===== GOOGLE APPS SCRIPT API CONFIG =====
        const API_URL = 'https://script.google.com/macros/s/AKfycbxzdOGbJgp7zz2IVtnD-sbcyKpcEPSuRGMMq2fOe_0sL6vTwL3pUT2PQ0_Dg43dAxHAoQ/exec';

        // ===== GAME CONSTANTS =====
        const SYMBOLS = ['ğŸ’', 'ğŸ‘‘', 'ğŸ”¥', 'â­', 'ğŸ’', 'ğŸ’–', 'ğŸŒ€', 'âš¡', 'ğŸ›¡ï¸'];
        const BET_OPTIONS = [100, 250, 500, 1000, 2500, 5000];
        const INITIAL_BALANCE = 10000;

        // ===== GOOGLE APPS SCRIPT API SERVICE =====
        class APIService {
            constructor() {
                this.apiUrl = API_URL;
                this.playerId = localStorage.getItem('slotPlayerId') || this.generatePlayerId();
                this.pendingSync = JSON.parse(localStorage.getItem('pendingSync') || '[]');
            }

            generatePlayerId() {
                const id = 'PLAYER_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('slotPlayerId', id);
                return id;
            }

            async makeRequest(action, params = {}) {
                try {
                    // Ø¨Ù†Ø§Ø¡ URL Ù…Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù…Ø§Øª
                    const urlParams = new URLSearchParams({
                        action: action,
                        ...params,
                        timestamp: Date.now(),
                        playerId: this.playerId
                    });
                    
                    const url = `${this.apiUrl}?${urlParams}`;
                    
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    return data;
                    
                } catch (error) {
                    console.warn(`API request failed for ${action}:`, error);
                    return { 
                        success: false, 
                        error: error.message,
                        message: 'API connection failed'
                    };
                }
            }

            async ping() {
                return await this.makeRequest('ping');
            }

            async getStats() {
                return await this.makeRequest('getStats');
            }

            async getStores() {
                return await this.makeRequest('getStores');
            }

            async initializeDatabase() {
                return await this.makeRequest('initialize');
            }

            async savePlayerData(playerData) {
                try {
                    const formData = new URLSearchParams();
                    formData.append('action', 'savePlayer');
                    formData.append('playerData', JSON.stringify(playerData));
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    return await response.json();
                    
                } catch (error) {
                    console.warn('Failed to save player data:', error);
                    this.addToPendingSync('player', playerData);
                    return { 
                        success: true, 
                        message: 'Data queued for later sync',
                        queued: true 
                    };
                }
            }

            async saveGameData(gameData) {
                try {
                    const formData = new URLSearchParams();
                    formData.append('action', 'saveGame');
                    formData.append('gameData', JSON.stringify(gameData));
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    return await response.json();
                    
                } catch (error) {
                    console.warn('Failed to save game data:', error);
                    this.addToPendingSync('game', gameData);
                    return { 
                        success: true, 
                        message: 'Game data queued for sync',
                        queued: true 
                    };
                }
            }

            async updateStores(storesData) {
                try {
                    const formData = new URLSearchParams();
                    formData.append('action', 'updateStores');
                    formData.append('storesData', JSON.stringify(storesData));
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    return await response.json();
                    
                } catch (error) {
                    console.warn('Failed to update stores:', error);
                    this.addToPendingSync('stores', storesData);
                    return { 
                        success: true, 
                        message: 'Stores data queued for sync',
                        queued: true 
                    };
                }
            }

            addToPendingSync(type, data) {
                this.pendingSync.push({
                    type: type,
                    data: data,
                    timestamp: Date.now()
                });
                localStorage.setItem('pendingSync', JSON.stringify(this.pendingSync));
            }

            async syncPendingData() {
                if (this.pendingSync.length === 0) {
                    return { success: true, message: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹Ù„Ù‚Ø©' };
                }

                let synced = 0;
                let failed = 0;
                
                for (let i = this.pendingSync.length - 1; i >= 0; i--) {
                    const item = this.pendingSync[i];
                    
                    try {
                        let result;
                        
                        switch(item.type) {
                            case 'player':
                                result = await this.savePlayerData(item.data);
                                break;
                            case 'game':
                                result = await this.saveGameData(item.data);
                                break;
                            case 'stores':
                                result = await this.updateStores(item.data);
                                break;
                        }
                        
                        if (result.success) {
                            this.pendingSync.splice(i, 1);
                            synced++;
                        } else {
                            failed++;
                        }
                        
                    } catch (error) {
                        console.error('Error syncing item:', error);
                        failed++;
                    }
                }
                
                localStorage.setItem('pendingSync', JSON.stringify(this.pendingSync));
                
                return { 
                    success: true, 
                    message: `ØªÙ…Øª Ù…Ø²Ø§Ù…Ù†Ø© ${synced} Ø¹Ù†Ø§ØµØ±ØŒ ÙØ´Ù„ ${failed}`,
                    synced: synced,
                    failed: failed
                };
            }
        }

        // ===== GAME CLASS =====
        class SlotGame {
            constructor() {
                this.balance = INITIAL_BALANCE;
                this.currentBet = 500;
                this.isSpinning = false;
                this.totalSpins = 0;
                this.totalWins = 0;
                this.totalWon = 0;
                this.biggestWin = 0;
                this.consecutiveLosses = 0;
                
                // Stores System
                this.stores = {
                    store1: { balance: 300000, target: 0.30 },
                    store2: { balance: 900000, target: 0.50 },
                    store3: { balance: 200000, target: 0.20, maxUsage: 0.10 }
                };
                
                // Grid
                this.grid = Array(3).fill().map(() => Array(5).fill(null));
                
                // API Service
                this.api = new APIService();
                this.cloudConnected = false;
                
                // DOM Elements
                this.elements = {
                    loading: document.getElementById('loading'),
                    loadingMessage: document.getElementById('loadingMessage'),
                    cloudStatus: document.getElementById('cloudStatus'),
                    syncBtn: document.getElementById('syncBtn'),
                    reels: document.getElementById('reels'),
                    balance: document.getElementById('balance'),
                    currentBet: document.getElementById('currentBet'),
                    spinBtn: document.getElementById('spinBtn'),
                    stopBtn: document.getElementById('stopBtn'),
                    soundToggle: document.getElementById('soundToggle'),
                    resetGame: document.getElementById('resetGame'),
                    winDisplay: document.getElementById('winDisplay'),
                    winAmount: document.getElementById('winAmount'),
                    winMultiplier: document.getElementById('winMultiplier'),
                    closeWin: document.getElementById('closeWin'),
                    toast: document.getElementById('toast'),
                    playerId: document.getElementById('playerId'),
                    
                    // Stores
                    store1Amount: document.getElementById('store1Amount'),
                    store1Fill: document.getElementById('store1Fill'),
                    store2Amount: document.getElementById('store2Amount'),
                    store2Fill: document.getElementById('store2Fill'),
                    store3Amount: document.getElementById('store3Amount'),
                    store3Fill: document.getElementById('store3Fill'),
                    
                    // Stats
                    totalSpins: document.getElementById('totalSpins'),
                    winRate: document.getElementById('winRate'),
                    biggestWin: document.getElementById('biggestWin'),
                    rtpRate: document.getElementById('rtpRate')
                };
                
                // Audio
                this.audio = {
                    spin: document.getElementById('spinSound'),
                    stop: document.getElementById('stopSound'),
                    win: document.getElementById('winSound'),
                    click: document.getElementById('clickSound')
                };
                
                this.soundEnabled = true;
                this.lastGameResult = null;
                this.lastStoreUsed = null;
            }
            
            async init() {
                this.createGrid();
                this.setupEventListeners();
                await this.loadGameData();
                this.updateUI();
                
                await this.testCloudConnection();
                
                setTimeout(() => {
                    this.elements.loading.style.display = 'none';
                }, 1500);
            }
            
            async testCloudConnection() {
                try {
                    this.elements.loadingMessage.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³Ø­Ø§Ø¨Ø©...';
                    
                    const pingResult = await this.api.ping();
                    
                    if (pingResult.success) {
                        this.cloudConnected = true;
                        this.elements.cloudStatus.innerHTML = '<i class="fas fa-cloud"></i> <span>Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³Ø­Ø§Ø¨Ø©</span>';
                        this.elements.cloudStatus.classList.remove('disconnected');
                        this.elements.cloudStatus.classList.add('connected');
                        
                        await this.loadCloudData();
                        
                        this.showToast('âœ… Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³Ø­Ø§Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
                    } else {
                        this.setOfflineMode();
                    }
                } catch (error) {
                    console.log('Cloud connection failed:', error);
                    this.setOfflineMode();
                }
            }
            
            setOfflineMode() {
                this.cloudConnected = false;
                this.elements.cloudStatus.innerHTML = '<i class="fas fa-cloud-slash"></i> <span>ÙˆØ¶Ø¹ Ø¹Ø¯Ù… Ø§Ù„Ø§ØªØµØ§Ù„</span>';
                this.elements.cloudStatus.classList.remove('connected');
                this.elements.cloudStatus.classList.add('disconnected');
                
                this.showToast('âš ï¸ Ø§Ù„Ø¹Ù…Ù„ ÙÙŠ ÙˆØ¶Ø¹ Ø¹Ø¯Ù… Ø§Ù„Ø§ØªØµØ§Ù„', 'warning');
            }
            
            async loadCloudData() {
                if (!this.cloudConnected) return;
                
                try {
                    const statsResult = await this.api.getStats();
                    if (statsResult.success) {
                        this.updateGlobalStats(statsResult.stats);
                    }
                    
                    const storesResult = await this.api.getStores();
                    if (storesResult.success) {
                        this.stores.store1.balance = storesResult.stores.Store1?.balance || this.stores.store1.balance;
                        this.stores.store2.balance = storesResult.stores.Store2?.balance || this.stores.store2.balance;
                        this.stores.store3.balance = storesResult.stores.Store3?.balance || this.stores.store3.balance;
                    }
                    
                } catch (error) {
                    console.warn('Error loading cloud data:', error);
                }
            }
            
            updateGlobalStats(cloudStats) {
                if (cloudStats.totalPlayers > 0) {
                    console.log('Global stats loaded:', cloudStats);
                }
            }
            
            async syncWithCloud() {
                try {
                    this.showToast('ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ù…Ø¹ Ø§Ù„Ø³Ø­Ø§Ø¨Ø©...', 'info');
                    
                    const syncResult = await this.api.syncPendingData();
                    
                    if (syncResult.success) {
                        if (syncResult.synced > 0) {
                            this.showToast(`âœ… ØªÙ…Øª Ù…Ø²Ø§Ù…Ù†Ø© ${syncResult.synced} Ø¹Ù†ØµØ±`, 'success');
                        } else {
                            this.showToast('âœ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­Ø¯Ø«Ø© Ø¨Ø§Ù„ÙØ¹Ù„', 'info');
                        }
                        
                        await this.loadCloudData();
                    } else {
                        this.showToast('âŒ ÙØ´Ù„Øª Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©', 'error');
                    }
                } catch (error) {
                    this.showToast('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©', 'error');
                    console.error('Sync error:', error);
                }
            }
            
            createGrid() {
                this.elements.reels.innerHTML = '';
                
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 5; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'reel-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.textContent = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
                        this.elements.reels.appendChild(cell);
                        this.grid[row][col] = cell.textContent;
                    }
                }
            }
            
            setupEventListeners() {
                this.elements.spinBtn.addEventListener('click', () => this.spin());
                this.elements.stopBtn.addEventListener('click', () => this.stop());
                
                document.querySelectorAll('.btn-bet').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const bet = parseInt(e.target.dataset.bet);
                        this.setBet(bet);
                        this.playSound('click');
                    });
                });
                
                this.elements.closeWin.addEventListener('click', () => {
                    this.elements.winDisplay.classList.remove('active');
                    this.playSound('click');
                });
                
                this.elements.soundToggle.addEventListener('click', () => {
                    this.toggleSound();
                });
                
                this.elements.resetGame.addEventListener('click', () => {
                    this.resetGame();
                });
                
                this.elements.syncBtn.addEventListener('click', () => {
                    this.syncWithCloud();
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if (this.isSpinning) {
                            this.stop();
                        } else {
                            this.spin();
                        }
                    }
                });
            }
            
            setBet(bet) {
                if (this.isSpinning) return;
                
                this.currentBet = bet;
                
                document.querySelectorAll('.btn-bet').forEach(btn => {
                    const btnBet = parseInt(btn.dataset.bet);
                    if (btnBet === bet) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                
                this.elements.currentBet.textContent = bet.toLocaleString();
                this.playSound('click');
            }
            
            async spin() {
                if (this.isSpinning) return;
                
                if (this.balance < this.currentBet) {
                    this.showToast('Ø±ØµÙŠØ¯Ùƒ ØºÙŠØ± ÙƒØ§ÙÙŠ!', 'error');
                    return;
                }
                
                this.balance -= this.currentBet;
                this.totalSpins++;
                this.consecutiveLosses++;
                
                this.addToStores(this.currentBet);
                
                this.isSpinning = true;
                this.elements.spinBtn.disabled = true;
                this.elements.stopBtn.disabled = false;
                
                this.playSound('spin');
                this.animateSpin();
                this.generateResults();
                
                setTimeout(() => {
                    if (this.isSpinning) {
                        this.stop();
                    }
                }, 3000);
                
                this.updateUI();
                await this.saveGameData();
            }
            
            animateSpin() {
                const cells = document.querySelectorAll('.reel-cell');
                cells.forEach(cell => {
                    cell.classList.add('spinning');
                    
                    const interval = setInterval(() => {
                        cell.textContent = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
                    }, 50);
                    
                    cell.dataset.interval = interval;
                });
            }
            
            generateResults() {
                const volatility = this.getVolatility();
                
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 5; col++) {
                        this.grid[row][col] = this.getWeightedSymbol(volatility);
                    }
                }
                
                this.applyStoreLogic();
                
                if (this.consecutiveLosses >= 8) {
                    this.forceWin();
                    this.consecutiveLosses = 0;
                }
            }
            
            getVolatility() {
                const totalBalance = this.getTotalStoreBalance();
                const avgBalance = totalBalance / 3;
                
                const lowStores = Object.values(this.stores).filter(
                    store => store.balance < avgBalance * 0.3
                ).length;
                
                if (lowStores > 0) return 'low';
                
                const highStores = Object.values(this.stores).filter(
                    store => store.balance > avgBalance * 1.7
                ).length;
                
                if (highStores > 0) return 'high';
                
                return 'medium';
            }
            
            getWeightedSymbol(volatility) {
                const weights = {
                    low: [15, 12, 10, 8, 7, 6, 5, 4, 3],
                    medium: [5, 8, 10, 12, 15, 12, 10, 8, 5],
                    high: [3, 4, 5, 6, 7, 8, 10, 12, 15]
                };
                
                const weightArray = weights[volatility];
                const totalWeight = weightArray.reduce((a, b) => a + b, 0);
                let random = Math.random() * totalWeight;
                
                for (let i = 0; i < SYMBOLS.length; i++) {
                    random -= weightArray[i];
                    if (random <= 0) {
                        return SYMBOLS[i];
                    }
                }
                
                return SYMBOLS[SYMBOLS.length - 1];
            }
            
            applyStoreLogic() {
                const store1 = this.stores.store1;
                const store2 = this.stores.store2;
                const totalBalance = this.getTotalStoreBalance();
                
                const store1Target = (store1.balance / totalBalance) * 0.4;
                const store2Target = (store2.balance / totalBalance) * 0.4;
                
                const store1Chance = Math.max(0.2, Math.min(0.8, store1Target));
                const store2Chance = Math.max(0.1, Math.min(0.6, store2Target));
                
                const storeChoice = Math.random();
                let useStore = null;
                
                if (storeChoice < store1Chance) {
                    useStore = 'store1';
                } else if (storeChoice < store1Chance + store2Chance) {
                    useStore = 'store2';
                }
                
                if (useStore) {
                    this.createStoreWin(useStore);
                }
            }
            
            createStoreWin(storeName) {
                const winType = storeName === 'store1' ? 
                    (Math.random() < 0.7 ? 'small' : 'medium') :
                    (Math.random() < 0.5 ? 'medium' : 'large');
                
                const symbol = this.getStoreSymbol(storeName, winType);
                const matchLength = winType === 'small' ? 3 : winType === 'medium' ? 4 : 5;
                const row = Math.floor(Math.random() * 3);
                
                for (let col = 0; col < matchLength; col++) {
                    this.grid[row][col] = symbol;
                }
            }
            
            getStoreSymbol(storeName, winType) {
                if (storeName === 'store1') {
                    return SYMBOLS[winType === 'small' ? 
                        Math.floor(Math.random() * 6) + 3 :
                        Math.floor(Math.random() * 3) + 6];
                } else {
                    return SYMBOLS[winType === 'medium' ? 
                        Math.floor(Math.random() * 3) + 3 :
                        Math.floor(Math.random() * 3)];
                }
            }
            
            forceWin() {
                const row = Math.floor(Math.random() * 3);
                const symbol = SYMBOLS[Math.floor(Math.random() * 3) + 6];
                
                for (let col = 0; col < 3; col++) {
                    this.grid[row][col] = symbol;
                }
                
                this.showToast('ğŸ€ Ø­Ø¸Ø§Ù‹ Ø£ÙØ¶Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø©!', 'warning');
            }
            
            async stop() {
                if (!this.isSpinning) return;
                
                this.isSpinning = false;
                this.elements.spinBtn.disabled = false;
                this.elements.stopBtn.disabled = true;
                
                const cells = document.querySelectorAll('.reel-cell');
                cells.forEach(cell => {
                    cell.classList.remove('spinning');
                    clearInterval(cell.dataset.interval);
                });
                
                this.playSound('stop');
                this.showResults();
                
                setTimeout(async () => {
                    const results = this.checkWins();
                    await this.processResults(results);
                }, 500);
            }
            
            showResults() {
                const cells = document.querySelectorAll('.reel-cell');
                
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    cell.textContent = this.grid[row][col];
                });
            }
            
            checkWins() {
                const results = {
                    wins: [],
                    totalMultiplier: 0,
                    totalWin: 0
                };
                
                // Check horizontal lines
                for (let row = 0; row < 3; row++) {
                    const line = this.grid[row];
                    let count = 1;
                    let currentSymbol = line[0];
                    
                    for (let col = 1; col < 5; col++) {
                        if (line[col] === currentSymbol) {
                            count++;
                        } else {
                            break;
                        }
                    }
                    
                    if (count >= 3) {
                        const multiplier = count === 3 ? 1 : count === 4 ? 3 : 15;
                        results.wins.push({
                            type: 'horizontal',
                            row: row,
                            count: count,
                            symbol: currentSymbol,
                            multiplier: multiplier
                        });
                        results.totalMultiplier += multiplier;
                        results.totalWin += this.currentBet * multiplier;
                    }
                }
                
                // Check V shape
                const vPositions = [[0,0], [1,1], [2,2], [1,3], [0,4]];
                const vSymbols = vPositions.map(([r, c]) => this.grid[r][c]);
                const isV = vSymbols.every(s => s === vSymbols[0]);
                
                if (isV) {
                    results.wins.push({
                        type: 'v-shape',
                        count: 5,
                        symbol: vSymbols[0],
                        multiplier: 15
                    });
                    results.totalMultiplier += 15;
                    results.totalWin += this.currentBet * 15;
                }
                
                return results;
            }
            
            async processResults(results) {
                this.highlightWins(results);
                
                if (results.totalWin > 0) {
                    this.consecutiveLosses = 0;
                    this.totalWins++;
                    this.totalWon += results.totalWin;
                    this.balance += results.totalWin;
                    
                    if (results.totalWin > this.biggestWin) {
                        this.biggestWin = results.totalWin;
                    }
                    
                    this.lastStoreUsed = this.deductFromStores(results.totalWin);
                    
                    if (results.totalWin >= this.currentBet * 10) {
                        this.playSound('win');
                    }
                    
                    this.showWinDisplay(results.totalWin, results.totalMultiplier);
                    
                    if (results.totalWin >= this.currentBet * 15) {
                        this.showToast(`ğŸŠ ÙÙˆØ² ÙƒØ¨ÙŠØ±! ${results.totalWin.toLocaleString()}`, 'success');
                    }
                    
                    this.lastGameResult = results;
                    
                } else {
                    const nearWins = this.checkNearWins();
                    if (nearWins > 0) {
                        this.showToast('âš¡ ÙƒØ§Ø¯Øª Ø£Ù† ØªÙÙˆØ²!', 'warning');
                    }
                }
                
                this.updateUI();
                await this.saveGameData();
            }
            
            highlightWins(results) {
                document.querySelectorAll('.reel-cell').forEach(cell => {
                    cell.classList.remove('matched');
                });
                
                results.wins.forEach(win => {
                    if (win.type === 'horizontal') {
                        for (let col = 0; col < win.count; col++) {
                            const cell = document.querySelector(
                                `.reel-cell[data-row="${win.row}"][data-col="${col}"]`
                            );
                            if (cell) cell.classList.add('matched');
                        }
                    } else if (win.type === 'v-shape') {
                        const positions = [[0,0], [1,1], [2,2], [1,3], [0,4]];
                        positions.forEach(([row, col]) => {
                            const cell = document.querySelector(
                                `.reel-cell[data-row="${row}"][data-col="${col}"]`
                            );
                            if (cell) cell.classList.add('matched');
                        });
                    }
                });
            }
            
            checkNearWins() {
                let nearWins = 0;
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (this.grid[row][col] === this.grid[row][col + 1]) {
                            nearWins++;
                        }
                    }
                }
                return nearWins;
            }
            
            showWinDisplay(amount, multiplier) {
                this.elements.winAmount.textContent = amount.toLocaleString();
                this.elements.winMultiplier.textContent = `Ã—${multiplier}`;
                this.elements.winDisplay.classList.add('active');
            }
            
            // ===== STORES SYSTEM =====
            getTotalStoreBalance() {
                return Object.values(this.stores).reduce((sum, store) => sum + store.balance, 0);
            }
            
            addToStores(amount) {
                const totalBalance = this.getTotalStoreBalance();
                
                let targets = {
                    store1: 0.30,
                    store2: 0.50,
                    store3: 0.20
                };
                
                Object.keys(this.stores).forEach(storeKey => {
                    const store = this.stores[storeKey];
                    const currentPercentage = store.balance / totalBalance;
                    const targetPercentage = targets[storeKey];
                    
                    if (currentPercentage < targetPercentage * 0.5) {
                        targets[storeKey] = targetPercentage * 1.5;
                        Object.keys(targets).forEach(key => {
                            if (key !== storeKey) {
                                targets[key] *= 0.9;
                            }
                        });
                    }
                });
                
                const totalTarget = Object.values(targets).reduce((a, b) => a + b, 0);
                Object.keys(targets).forEach(key => {
                    targets[key] /= totalTarget;
                });
                
                Object.keys(this.stores).forEach(storeKey => {
                    this.stores[storeKey].balance += amount * targets[storeKey];
                });
                
                this.rebalanceStores();
            }
            
            deductFromStores(amount) {
                let remaining = amount;
                let storeUsed = 'none';
                
                if (this.stores.store1.balance >= amount * 0.7) {
                    this.stores.store1.balance -= amount * 0.7;
                    remaining -= amount * 0.7;
                    storeUsed = 'store1';
                } else if (this.stores.store1.balance > 0) {
                    remaining -= this.stores.store1.balance;
                    this.stores.store1.balance = 0;
                    storeUsed = 'store1';
                }
                
                if (remaining > 0 && this.stores.store2.balance >= remaining) {
                    this.stores.store2.balance -= remaining;
                    remaining = 0;
                    storeUsed = storeUsed === 'store1' ? 'both' : 'store2';
                } else if (remaining > 0 && this.stores.store2.balance > 0) {
                    remaining -= this.stores.store2.balance;
                    this.stores.store2.balance = 0;
                    storeUsed = storeUsed === 'store1' ? 'both' : 'store2';
                }
                
                if (remaining > 0) {
                    const maxEmergency = this.stores.store3.balance * this.stores.store3.maxUsage;
                    const actualDeduction = Math.min(remaining, maxEmergency);
                    
                    this.stores.store3.balance -= actualDeduction;
                    
                    if (actualDeduction > 0) {
                        this.showToast('âš ï¸ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø®Ø²Ù† Ø§Ù„Ø·ÙˆØ§Ø±Ø¦', 'warning');
                        storeUsed = 'emergency';
                    }
                }
                
                this.rebalanceStores();
                return storeUsed;
            }
            
            rebalanceStores() {
                const totalBalance = this.getTotalStoreBalance();
                
                const targets = {
                    store1: totalBalance * this.stores.store1.target,
                    store2: totalBalance * this.stores.store2.target,
                    store3: totalBalance * this.stores.store3.target
                };
                
                const imbalances = {};
                Object.keys(this.stores).forEach(storeKey => {
                    imbalances[storeKey] = this.stores[storeKey].balance - targets[storeKey];
                });
                
                Object.keys(imbalances).forEach(sourceKey => {
                    if (imbalances[sourceKey] > 0) {
                        Object.keys(imbalances).forEach(targetKey => {
                            if (targetKey !== sourceKey && imbalances[targetKey] < 0) {
                                const transfer = Math.min(
                                    imbalances[sourceKey],
                                    -imbalances[targetKey]
                                );
                                
                                if (transfer > 0) {
                                    this.stores[sourceKey].balance -= transfer;
                                    this.stores[targetKey].balance += transfer;
                                    
                                    imbalances[sourceKey] -= transfer;
                                    imbalances[targetKey] += transfer;
                                }
                            }
                        });
                    }
                });
            }
            
            // ===== AUDIO =====
            playSound(soundName) {
                if (!this.soundEnabled || !this.audio[soundName]) return;
                
                try {
                    const sound = this.audio[soundName].cloneNode();
                    sound.volume = 0.4;
                    sound.play().catch(() => {});
                } catch (error) {
                    console.warn('Error playing sound:', error);
                }
            }
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                
                const icon = this.elements.soundToggle.querySelector('i');
                icon.className = this.soundEnabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';
                
                localStorage.setItem('slotSoundEnabled', this.soundEnabled.toString());
                
                const message = this.soundEnabled ? 'ğŸ”Š Ø§Ù„ØµÙˆØª Ù…ÙØ¹Ù„' : 'ğŸ”‡ Ø§Ù„ØµÙˆØª Ù…Ø¹Ø·Ù„';
                this.showToast(message);
                
                if (this.soundEnabled) {
                    this.playSound('click');
                }
            }
            
            // ===== UI =====
            updateUI() {
                this.elements.balance.textContent = this.balance.toLocaleString();
                
                const totalStoreBalance = this.getTotalStoreBalance();
                
                Object.keys(this.stores).forEach((storeKey, index) => {
                    const store = this.stores[storeKey];
                    const percentage = (store.balance / totalStoreBalance) * 100;
                    const displayPercentage = (store.balance / (storeKey === 'store1' ? 500000 : 
                                                                storeKey === 'store2' ? 1500000 : 400000)) * 100;
                    
                    this.elements[`store${index + 1}Amount`].textContent = 
                        Math.round(store.balance).toLocaleString();
                    
                    const fillElement = this.elements[`store${index + 1}Fill`];
                    fillElement.style.width = `${Math.min(displayPercentage, 100)}%`;
                });
                
                this.elements.totalSpins.textContent = this.totalSpins.toLocaleString();
                
                const winRate = this.totalSpins > 0 ? 
                    ((this.totalWins / this.totalSpins) * 100).toFixed(1) : 0;
                this.elements.winRate.textContent = `${winRate}%`;
                
                this.elements.biggestWin.textContent = this.biggestWin.toLocaleString();
                
                const totalBet = this.totalSpins * this.currentBet;
                const rtp = totalBet > 0 ? 
                    ((this.totalWon / totalBet) * 100).toFixed(1) : 96.5;
                this.elements.rtpRate.textContent = `${Math.min(rtp, 99.9)}%`;
                
                this.elements.playerId.textContent = `ID: ${this.api.playerId.substr(0, 8)}...`;
            }
            
            showToast(message, type = 'info') {
                const toast = this.elements.toast;
                toast.textContent = message;
                
                toast.className = 'toast';
                if (type === 'error') toast.style.borderRightColor = 'var(--danger)';
                else if (type === 'warning') toast.style.borderRightColor = 'var(--warning)';
                else if (type === 'success') toast.style.borderRightColor = 'var(--accent)';
                else toast.style.borderRightColor = 'var(--info)';
                
                toast.classList.add('show');
                
                clearTimeout(this.toastTimeout);
                this.toastTimeout = setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            // ===== DATA MANAGEMENT =====
            async loadGameData() {
                try {
                    const saved = localStorage.getItem('slotGameData');
                    if (saved) {
                        const data = JSON.parse(saved);
                        
                        this.balance = data.balance || INITIAL_BALANCE;
                        this.currentBet = data.currentBet || 500;
                        this.totalSpins = data.totalSpins || 0;
                        this.totalWins = data.totalWins || 0;
                        this.totalWon = data.totalWon || 0;
                        this.biggestWin = data.biggestWin || 0;
                        
                        const savedStores = localStorage.getItem('slotStores');
                        if (savedStores) {
                            const storesData = JSON.parse(savedStores);
                            Object.keys(storesData).forEach(key => {
                                if (this.stores[key]) {
                                    this.stores[key].balance = storesData[key].balance || this.stores[key].balance;
                                }
                            });
                        }
                    }
                    
                    this.soundEnabled = localStorage.getItem('slotSoundEnabled') !== 'false';
                    const icon = this.elements.soundToggle.querySelector('i');
                    icon.className = this.soundEnabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';
                    
                } catch (error) {
                    console.error('Error loading game data:', error);
                }
            }
            
            async saveGameData() {
                // Ø­ÙØ¸ Ù…Ø­Ù„ÙŠ
                const gameData = {
                    balance: this.balance,
                    currentBet: this.currentBet,
                    totalSpins: this.totalSpins,
                    totalWins: this.totalWins,
                    totalWon: this.totalWon,
                    biggestWin: this.biggestWin
                };
                
                localStorage.setItem('slotGameData', JSON.stringify(gameData));
                localStorage.setItem('slotStores', JSON.stringify(this.stores));
                
                // Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨
                await this.api.savePlayerData({
                    id: this.api.playerId,
                    name: `Player_${this.api.playerId.substr(0, 6)}`,
                    balance: this.balance,
                    spins: this.totalSpins,
                    wins: this.totalWins,
                    totalWin: this.totalWon
                });
                
                // Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø§Ø²Ù†
                await this.api.updateStores({
                    Store1: {
                        balance: this.stores.store1.balance,
                        maxLimit: 500000,
                        minLimit: 100000
                    },
                    Store2: {
                        balance: this.stores.store2.balance,
                        maxLimit: 1500000,
                        minLimit: 300000
                    },
                    Store3: {
                        balance: this.stores.store3.balance,
                        maxLimit: 400000,
                        minLimit: 50000
                    }
                });
                
                // Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ù„Ø³Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ ÙÙˆØ²
                if (this.lastGameResult && this.lastGameResult.totalWin > 0) {
                    await this.api.saveGameData({
                        playerId: this.api.playerId,
                        bet: this.currentBet,
                        win: this.lastGameResult.totalWin,
                        storeUsed: this.lastStoreUsed || 'none',
                        multiplier: this.lastGameResult.totalMultiplier
                    });
                }
            }
            
            resetGame() {
                if (!confirm('âš ï¸ Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù„Ø¹Ø¨Ø©ØŸ\nØ³ÙŠØªÙ… ÙÙ‚Ø¯Ø§Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ‚Ø¯Ù… ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª.')) {
                    return;
                }
                
                this.balance = INITIAL_BALANCE;
                this.currentBet = 500;
                this.totalSpins = 0;
                this.totalWins = 0;
                this.totalWon = 0;
                this.biggestWin = 0;
                this.consecutiveLosses = 0;
                
                this.stores = {
                    store1: { balance: 300000, target: 0.30 },
                    store2: { balance: 900000, target: 0.50 },
                    store3: { balance: 200000, target: 0.20, maxUsage: 0.10 }
                };
                
                this.createGrid();
                
                localStorage.removeItem('slotGameData');
                localStorage.removeItem('slotStores');
                localStorage.removeItem('pendingSync');
                
                document.querySelectorAll('.btn-bet').forEach(btn => {
                    const btnBet = parseInt(btn.dataset.bet);
                    if (btnBet === 500) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                
                this.updateUI();
                this.showToast('ğŸ”„ ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­!', 'success');
            }
        }

        // ===== INITIALIZE GAME =====
        window.addEventListener('DOMContentLoaded', async () => {
            window.slotGame = new SlotGame();
            await window.slotGame.init();
        });
    </script>
</body>
</html>
